# 아이템71. 필요 없는 검사 예외 사용은 피하라

검사 예외(Checked Exception)를 싫어하는 자바 프로그래머가 많지만, 제대로 활용하면 API와 프로그램의 질을 높일 수 있다.

호출 결과를 반환하거나 비검사 예외를 던지는 것과 달리, **검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다**.   
(물론 발생한 문제를 프로그래머가 처리할 수 있는 상황일 때 검사 예외를 발생시켜야 한다.)

그렇다고 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다!   

어떤 메서드가 검사 예외를 던질 수 있다면, 메서드를 호출하는 쪽은 catch로 해당 예외를 잡아서 처리하거나 바깥으로 던져야 한다.   
어느 쪽이든 API 사용자에게 처리를 강요한다.   
(검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수도 없다)

API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우라면 API 사용자도 받아들일 수 있을것이다.   
만약 두 가지 경우 모두 해당하지 않는다면 비검사 예외를 사용하는 게 좋다.

검사 예외와 비검사 예외 중 어느 것을 선택해야 할지는 프로그래머가 그 예외를 어떻게 다룰지 생각해보면 알 수 있다.

```java
} catch (TheCheckedException e) {
    throw new AssertionError();  // 일어날 수 없는 상황이다.
}

// 또는

} catch (TheCheckedException e) {
    e.printStackTrace();  // 프로그래머에게 알리고 끝내겠다!
    System.exit(1);
}
```

위의 상황이 발생한다면 비검사 예외를 선택하자. 두 예시 모두 상황을 복구시키지 못하고 있다.

### 검사 예외가 부담이 된다면 검사 예외 회피를 고려해보자

검사 예외가 프로그래머에게 주는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 특히 크다.
이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 경우라면 기껏해야 catch문 하나 추가하는 선에서 끝이다.

하지만 검사 예외가 단 하나뿐이라면 오직 그 예외 때문에 API 사용자는 try 블록을 추가해야 하고 스트림에서 직접 사용하지 못하게 된다.   
(가장 부담이 되는 상황은 검사 예외를 던지는 경우!)
그러니 이런 상황이라면 검사 예외를 회피하는 방법을 고려해보자.

**검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것**이다.   
검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다. 이 방식의 단점이라면 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.   
(옵셔널이 빈 값을 반환한 이유를 담을 수 없다. 만약 한다면 주석으로 빈 옵셔널을 반환하는 경우를 명시해주는 걸로 타협이 가능할까..?)

> 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다.

**검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.**   
이 방식에서 첫 번째 메서드는 예외가 던져질지 여부를 boolean값으로 반환한다.

```java
try {
    obj.action(args);
} catch (TheCheckedException e) {
    // 예외 상황에 대처한다.
}

// 수정 후
if (obj.actionPermitted(args)) {
    obj.action(args);
} else {
    // 예외 상황에 대처한다.
}
```

이 수정 방법을 모든 상황에 적용할 수는 없다. 적용할 수만 있다면 사용자의 부담을 줄일 수 있다.

프로그래머가 이 메서드가 성공하리라는 걸 안다거나, 실패 시 스레드를 중단하길 원한다면 다음처럼 한 줄로 작성해도 무방하다.

```java
obj.action(args);
```

이 한 줄짜리 호출 방식이 주로 쓰일 거로 판단되면 리팩터링하는 편이 바람직하다.   
예시에서 actionPermmitted는 상태 검사 메서드에 해당하므로 아이템 69에서 말한 단점도 그대로 적용되니 주의해야 한다.   
즉, 외부 동기화 없이 여러 스레드가 동시에 접근하거나 외부 요인에 의해 상태가 변할 수 있다면 이 리팩터링은 적절하지 않다.   
(actionPermitted 와 action 호출 사이에 객체의 상태가 다른 스레드 외부 요인에 의해 변할 수 있기 때문)

또한 actionPermitted가 action 메서드의 작업 일부를 중복 수행한다면 성능에서 손해이니, 역시 이 리팩터링이 적절하지 않을 수 있다.

### 핵심 정리

검사 예외는 꼭 필요한 곳에만 사용한다면 프로그램의 안전성을 높여준다.   
하지만 남용하면 사용하기 어려운 API가 된다.

API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.

복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우린 옵셔널을 반환해도 될지 고민하자.   
옵셔널로 상황에 대한 정보를 제공할 수 없을 때만 검사 예외를 던지자.

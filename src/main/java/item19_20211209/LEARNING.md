# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

문서화해놓지 않은 '외부' 클래스를 상속할 때는 위험하다. 
여기서 '외부'란 프로그래머의 통제권 밖에 있어서 언제 어떻게 변경될 지 모른다는 뜻이다.

### 상속을 고려한 문서화

메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.

> 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.

예를들어, 클래스 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다.   
이때 또 다른 메서드가 재정의 가능한 메서드라면 그 사실을 API 설명에 명시해야한다.   
추가로 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다. 더 크게는 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야한다.

> '재정의 가능'이란 public 과 protected 메서드 중 final이 아닌 모든 메서드를 의미한다.

API 문서의 메서드 설명 끝에는 종종 "implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.

> "implementation Requirements는 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다."

하지만 이런 식은 "좋은 API 문서란 '어떻게'가 아니라 '무엇'을 하는지를 설명해야 한다" 라는 격언과는 대치되지 않나?   
-> 맞는말이다. 상속이 캡슐화를 해치기 때문에 일어나는 안타까운 현실이다.

클래스를 안전하게 상속하려면 상속을 위해 주의해야 할 내부 구현 방식을 설명해야한다.

> @implSpec 태그는 자바8에서 처음 도입되어 자바 9부터 본격적으로 사용되기 시작했다.   
> 이 태그가 기본값으로 활성화되어야 바람직하다고 생각하지만 자바 11의 자바독에서도 선택사항으로 남겨져 있다.   
> 이 태그를 활성화하려면 명령줄 매개변수로 -tag "implSpec:a:Implementation Requirements:"를 지정해주면 된다.

### 상속을 고려한 설계

효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
(드물게는 protected 필드를 공개해야 할 수도 있다.)

상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할지는 어떻게 결정할까?   
이것에 정답은 없다. 심사숙고해서 잘 예측해본 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선이다.

protected 메서드는 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 한다. 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다.

> 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다.

꼭 필요한 protected 멤서를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다. 거꾸로, 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private 이었어야 할 가능성이 크다.   
이러한 검증에는 하위 클래스 3개 정도가 적당하고 그 중 하나 이상은 제 3자가 작성해야봐 한다.

### 상속용 클래스는 영원히 책임져야한다.

널리 쓰일 클래스를 상속용으로 설계한다면 우리가 문서화한 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을 잘 인식해야 한다. 
이 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다.

> 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

### 상속용 클래스의 생성자에서 재정의 가능 메서드 호출은 금지다.

이 규칙을 어기면 프로그램이 오동작 할 것이다.   
상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.

상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.
이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다.

```java
public class Super {

    public Super() {
        // 상속용 클래스에서 내부의 재정의 가능한 메서드를 호출함 - 안티패턴
        overrideMe();
    }

    // 재정의 가능 메서드
    public void overrideMe() {
    }
}
```

Super 클래스의 생성자를 보면 내부의 public 메서드(재정의 가능 메서드)인 overrideMe를 호출하고 있다.

```java
public final class Sub extends Super {
    // 초기화되지 않은 final 필드
    private final Object object;

    public Sub() {
        // super() 먼저 실행됨
        this.object = new Object();
    }

    @Override
    public void overrideMe() {
        System.out.println(object);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

```java
출력 결과 
null
java.lang.Object@7852e922
```

출력 결과를 보면 object 객체를 두번 출력했다. 하지만 첫 번쨰 object는 null을 출력했다.

그 이유는 Sub 클래스의 생성자에서 필드를 초기화하기도 전에 Suepr 클래스의 생성자에서 overrideMe를 호출했기 때문이다.   
이 클래스의 final 필드의 상태가 두 가지임에 주목하자(null 과 초기화된 상태)

### Cloneable 과 Serializable를 상속한 클래스

Cloneable 과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다. 

둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다.   
그 클래스를 확장하려는 프로그래머에게 엄청난 부담을 준다.

clone과 readObject 메서드는 생성자와 비슷한 효과를 낸다. 즉, 생성자와 비슷한 제약이 있다는 것이다.

앞서 말한것처럼 생성자에는 직접적으로든 간접적으로든 재정의 가능한 메서드를 호출하면 안된다. 

> 즉, clone과 readObject 메서드도 직접적으로든 간접적으로든 재정의 가능한 메서드를 호출하면 안된다.

Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다.

> [readResolve와 writeReplace 메서드란?](https://madplay.github.io/post/what-is-readresolve-method-and-writereplace-method)

private로 선언한다면 하위 클래스에서 무시되기 때문이다.

### 구체 클래스의 상속

일반적인 구체 클래스는 어떨까?

전통적으로 이런 클래스는 final도 아니고 상속용으로 설계되거나 문서화되지도 않았다. 그대로 두면 위험하다.

이 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지시키는 것이다.
이전 아이템에서도 나왔듯이 두 가지 방법이 있다.
* 클래스를 final로 선언하는것
  * final class Something { ...
* 생성자를 private 또는 package-private 으로 선언하고 정적 팩터리 메서드만 제공하는것


### 핵심 정리
상속용 클래스를 설계하기란 결코 만만치 않다. 
클래스 내부에서 스스로를 어떻게 사용하는지(자기 사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 
그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다. 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 
그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다.